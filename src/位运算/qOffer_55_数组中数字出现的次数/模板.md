链接:  https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/

#### qOffer_55_数组中数字出现的次数

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

 

**示例**

```java
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
    
输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
```

**提示**

- 2 <= nums.length <= 10000

**思路**: 

```java 
第一种使用map的思路. 统计数量, 返回, 时间复杂度O(n), 空间复杂度o(n)
    
 使用异或的操作.  
    所有相同的数有两个. 出现两次后那么结果为0, 因为有两个数不同. 所以最后的异或操作结果是
    这两个数的异或的和. 并且这两个数的异或结果一定不为0. 所以必定且至少存在某位不相等
    那么我们就可以根据这个掩码来进行分组. n&mask为0的为一组.  相同的数&mask必定相等. 
    这就导致原数被分为两组. 最后就是两个不相等的数.
    
    参考题解:  https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/jie-di-qi-jiang-jie-fen-zu-wei-yun-suan-by-eddievi/
    关键点在分组上： 4 ->100 ；1 ->001； 6 ->110； 4 ->100 ； 所有数字异或值为 k（这里是111），只要找到一个k中，位数为1的任意位号mask（ 这里用的是 while((k & mask) == 0) { mask <<= 1; } ），显然第一位就是mask，mask这个位号表示的是那两个不重复数的二进制（001、110）在这个位号上不同时为0或1的位置，那么锁定这样的位置后，以同样方法（使用(num & mask) == 0），将mask位不为1的剔出来为一组，而另一组中必然会有mask位为1的数，这样就实现了不重复的两个数分到了不同组，而那些重复数必然被分到相同的组中，最终被抵消。
```









