链接: https://leetcode-cn.com/problems/ones-and-zeroes/

在计算机界中，我们总是追求用有限的资源获取最大的收益。

现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。

你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。

注意:

 给定 0 和 1 的数量都不会超过 100。
		给定字符串数组的长度不会超过 600。
示例 1:

输入: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
输出: 4

解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 "10","0001","1","0" 。
示例 2:

输入: Array = {"10", "0", "1"}, m = 1, n = 1
输出: 2

解释: 你可以拼出 "10"，但之后就没有剩余数字了。更好的选择是拼出 "0" 和 "1" 。



思路:

字符数组可以转化为 0 1个数的数组

如: 输入: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3

题目变为:

```
原数    0的个数   1的个数  权重
10      1         1       1
0001    3         1       1
111001  2         4       1
1       0         1       1
0       1         0       1
    
m = 5(0), n = 3(1), 求权重最大为多少
```

现在转为01背包问题, 背包问题基本可以用转移方程的方式来进行解决

```
现在用dp[i][j]数组来表示最多放入字符串的个数, 其中i表示使用0的个数, j表示使用1的个数
则可以得出转移方程公式
    dp[i][j] = max{ dp[i][j], 1 + dp[i - 当前放入字符串0的个数][j - 当前放入字符串1的个数] }
即dp[i][j]的数值是由不放入当前字符串与放入当前字符串后(1+去掉当前字符串使用的0和1后对应[i-k][j-m]的个数)两者的最大值
```

这个方程含义的理解:

继续以上面的例子举例 m=5, n=3 初始化dp数组

`dp[5][3]`数组会多一行一列空余数据, 更方便讨论

| m\n  |  0   |  1   |  2   |  3   |
| :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |
|  1   |  0   |  0   |  0   |  0   |
|  2   |  0   |  0   |  0   |  0   |
|  3   |  0   |  0   |  0   |  0   |
|  4   |  0   |  0   |  0   |  0   |
|  5   |  0   |  0   |  0   |  0   |

**对于第一个01串 ‘10’**

对于所有`dp[i][j]`需要遍历, 重新更新符合情况(满足背包容量)的数据, 由于当前每个数字只能使用一次, 所以需要逆序遍历(有限背包), 正序遍历是(完全背包)

| m\n  |  0   |  1   |  2   |  3   |
| :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |
|  1   |  0   |  1   |  1   |  1   |
|  2   |  0   |  1   |  1   |  1   |
|  3   |  0   |  1   |  1   |  1   |
|  4   |  0   |  1   |  1   |  1   |
|  5   |  0   |  1   |  1   |  1   |

**对于 第二个01串‘0001’**

| m\n  |  0   |  1   |  2   |  3   |
| :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |
|  1   |  0   |  1   |  1   |  1   |
|  2   |  0   |  1   |  1   |  1   |
|  3   |  0   |  1   |  1   |  1   |
|  4   |  0   |  1   |  2   |  2   |
|  5   |  0   |  1   |  2   |  2   |

**对于 第三个串‘111001’**

| m\n  |  0   |  1   |  2   |  3   |
| :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |
|  1   |  0   |  1   |  1   |  1   |
|  2   |  0   |  1   |  1   |  1   |
|  3   |  0   |  1   |  1   |  1   |
|  4   |  0   |  1   |  2   |  2   |
|  5   |  0   |  1   |  2   |  2   |

**对于 第四个串‘1’**

| m\n  |  0   |  1   |  2   |  3   |
| :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |
|  1   |  0   |  1   |  2   |  2   |
|  2   |  0   |  1   |  2   |  2   |
|  3   |  0   |  1   |  2   |  2   |
|  4   |  0   |  1   |  2   |  3   |
|  5   |  0   |  1   |  2   |  3   |

**对于 第五个串‘0’**

| m\n  |  0   |  1   |  2   |  3   |
| :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  0   |  0   |
|  1   |  0   |  1   |  2   |  2   |
|  2   |  0   |  2   |  3   |  3   |
|  3   |  0   |  2   |  3   |  3   |
|  4   |  0   |  2   |  3   |  3   |
|  5   |  0   |  2   |  3   |  4   |

至此, 所有循环完毕, 最后`dp[5][3]`即是最终的结果