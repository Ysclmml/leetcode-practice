链接: https://leetcode-cn.com/problems/longest-increasing-subsequence/

q300_最长上升子序列

给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

**说明:**

+ 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。

+ 你算法的时间复杂度应该为 O(n2) 。

**进阶:**

 你能将算法的时间复杂度降低到 O(n log n) 吗?

**思路:**

使用一个`dp`数组, 原数组`nums[]`

`dp[i]`表示当前位置的最大有序序列长度, 下面的时间复杂度为O(n^2)

```
dp[i] = max { dp[i], 1 + dp[i - 1], 1 + dp[i - 2] + ... } if nums[i - n] < nums[i], n=1,2,3...,i-1
```

**思路2:**个人理解官方解法, 贪心算法`O(nlogn)`

想要获取最大上升子序列, 那么就需要使得获取相同长度的序列时,尽量使得末尾元素尽可能的小. 这样序列上升的就慢, 最后也就最长.

如此: 可以用一个数组`dp[i]`来描述长度为i的最长上升序列的最小末尾元素(这个最小是指代所有长度相同时,`dp[i]`是最小的那个末尾元素). 并且可以想象这个`dp[]`数组是单调上升的, 并且最后`dp`数组的长度就是最长上升序列的长度

证明思路选择反证法

```
现有数组dp[n], 当0<i<j时, 有dp[i]<dp[j], 即dp[n]是单调递增的
反证:
假设存在0<i<j时, dp[i]>=dp[j]
即当前长度为j的上升子序列A末尾元素最小为dp[j], 现在考虑删除这个序列末尾i-j个元素, 就获取到一个长度为i的新的上升子序列B, 这个序列的末尾元素为x, 那么因为B是A的子序列, 显然可以得出x < dp[j] < dp[i], 根据题设, dp[i]表示长度为i的序列的末尾元素最小是dp[i], 但是现在又存在长度为i的子序列B的末尾元素x<dp[i], 与题设矛盾, 那么假设不成立, dp[i]数组的单调递增的证.
```

得出`dp[i]`是单调递增的, 可以得出下面算法思路 

`dp[0]=num[0]`, 从1开始扫描原数组`num[]`

当`num[i] > dp[len-1]`时, 直接`dp[len]=num[i]`, 即`dp数组长度加1`

当`num[i] < dp[len-1]`时, 使用二分法扫描数组`dp[]`, 找到第一个大于`num[i]`的元素索引 `j`, 不存在为-1, 并且`dp[j+1] = num[i]` ,









